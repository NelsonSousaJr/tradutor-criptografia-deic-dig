<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tradutor de Criptografia Nerd</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #282c34;
            color: #abb2bf;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #3a404d;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            width: 100%;
            max-width: 700px;
            text-align: center;
        }
        h1 {
            color: #61afef;
            margin-bottom: 25px;
            font-size: 2em;
        }
        textarea {
            width: calc(100% - 20px);
            height: 120px;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #5c6370;
            border-radius: 5px;
            background-color: #21252b;
            color: #abb2bf;
            font-size: 1em;
            resize: vertical;
            box-sizing: border-box;
        }
        .output-area {
            background-color: #21252b;
            border: 1px solid #5c6370;
            border-radius: 5px;
            padding: 15px;
            min-height: 80px;
            text-align: left;
            word-wrap: break-word;
            font-size: 1em;
            color: #98c379;
        }
        label {
            display: block;
            text-align: left;
            margin-bottom: 8px;
            color: #c678dd;
            font-weight: bold;
        }
        select, input[type="file"], input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #5c6370;
            border-radius: 5px;
            background-color: #21252b;
            color: #abb2bf;
            font-size: 1em;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tradutor de Criptografia Nerd</h1>

        <label for="imageInput">Carregar Imagem com Texto:</label>
        <input type="file" id="imageInput" accept="image/*">

        <label for="encryptionMethod">Escolha o M√©todo de Criptografia:</label>
        <select id="encryptionMethod">
            <option value="keyword">Cifra de Palavra-Chave</option>
            <option value="atbash">Cifra de Atbash</option>
            <option value="caesarEmoji">Cifra de C√©sar (com Emoji)</option>
            <option value="vigenere">Cifra de Vigen√®re</option>
            <option value="elfico">Idioma √âlfico (Fict√≠cio)</option>
            <option value="binario">C√≥digo Bin√°rio</option>
        </select>

        <label for="messageInput">Digite sua mensagem (ou use OCR):</label>
        <textarea id="messageInput" placeholder="Sua mensagem secreta aqui..."></textarea>

        <label for="keywordInput" style="display: none;">Palavra-Chave (para Cifra de Palavra-Chave):</label>
        <input type="text" id="keywordInput" placeholder="Ex: NERD" style="display: none;">

        <label for="emojiInput" style="display: none;">Emoji (para Cifra de C√©sar):</label>
        <input type="text" id="emojiInput" placeholder="Ex: üöÄ" style="display: none;">

        <label for="vigenereInput" style="display: none;">Chave (para Cifra de Vigen√®re):</label>
        <input type="text" id="vigenereInput" placeholder="Ex: SEGREDO" style="display: none;">

        <label>Mensagem Criptografada:</label>
        <div class="output-area" id="encryptedOutput"></div>
    </div>

    <!-- Importando Tesseract.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <script>
        const messageInput = document.getElementById('messageInput');
        const encryptedOutput = document.getElementById('encryptedOutput');
        const encryptionMethodSelect = document.getElementById('encryptionMethod');
        const keywordInput = document.getElementById('keywordInput');
        const keywordLabel = document.querySelector('label[for="keywordInput"]');
        const emojiInput = document.getElementById('emojiInput');
        const emojiLabel = document.querySelector('label[for="emojiInput"]');
        const vigenereInput = document.getElementById('vigenereInput');
        const vigenereLabel = document.querySelector('label[for="vigenereInput"]');
        const imageInput = document.getElementById('imageInput');

        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // Fun√ß√µes de criptografia (mesmas do seu c√≥digo original) ----------------
        function generateKeywordCipherAlphabet(keyword) {
            let cleanKeyword = keyword.toUpperCase().replace(/[^A-Z]/g, '');
            let uniqueKeyword = '';
            for (let char of cleanKeyword) {
                if (!uniqueKeyword.includes(char)) {
                    uniqueKeyword += char;
                }
            }
            let cipherAlphabet = uniqueKeyword;
            for (let char of alphabet) {
                if (!cipherAlphabet.includes(char)) {
                    cipherAlphabet += char;
                }
            }
            return cipherAlphabet;
        }

        function encryptKeywordCipher(message, keyword) {
            if (!keyword) return message;
            const cipherAlphabet = generateKeywordCipherAlphabet(keyword);
            let encryptedMessage = '';
            for (let i = 0; i < message.length; i++) {
                const char = message[i].toUpperCase();
                const originalChar = message[i];
                const index = alphabet.indexOf(char);
                if (index !== -1) {
                    const encryptedChar = cipherAlphabet[index];
                    encryptedMessage += (originalChar === char) ? encryptedChar : encryptedChar.toLowerCase();
                } else {
                    encryptedMessage += originalChar;
                }
            }
            return encryptedMessage;
        }

        function encryptAtbash(message) {
            let encryptedMessage = '';
            for (let i = 0; i < message.length; i++) {
                const char = message[i].toUpperCase();
                const originalChar = message[i];
                const index = alphabet.indexOf(char);
                if (index !== -1) {
                    const encryptedChar = alphabet[alphabet.length - 1 - index];
                    encryptedMessage += (originalChar === char) ? encryptedChar : encryptedChar.toLowerCase();
                } else {
                    encryptedMessage += originalChar;
                }
            }
            return encryptedMessage;
        }

        function getEmojiShift(emoji) {
            if (!emoji) return 0;
            return emoji.length % alphabet.length;
        }

        function encryptCaesarCipher(message, emoji) {
            const shift = getEmojiShift(emoji);
            if (shift === 0) return message;
            let encryptedMessage = '';
            for (let i = 0; i < message.length; i++) {
                const char = message[i].toUpperCase();
                const originalChar = message[i];
                const index = alphabet.indexOf(char);
                if (index !== -1) {
                    const newIndex = (index + shift) % alphabet.length;
                    const encryptedChar = alphabet[newIndex];
                    encryptedMessage += (originalChar === char) ? encryptedChar : encryptedChar.toLowerCase();
                } else {
                    encryptedMessage += originalChar;
                }
            }
            return encryptedMessage;
        }

        function encryptVigenere(message, key) {
            if (!key) return message;
            const cleanKey = key.toUpperCase().replace(/[^A-Z]/g, '');
            if (cleanKey.length === 0) return message;

            let encryptedMessage = '';
            let keyIndex = 0;

            for (let i = 0; i < message.length; i++) {
                const char = message[i].toUpperCase();
                const originalChar = message[i];
                const charIndex = alphabet.indexOf(char);
                if (charIndex !== -1) {
                    const keyChar = cleanKey[keyIndex % cleanKey.length];
                    const keyCharIndex = alphabet.indexOf(keyChar);
                    const newIndex = (charIndex + keyCharIndex) % alphabet.length;
                    const encryptedChar = alphabet[newIndex];
                    encryptedMessage += (originalChar === char) ? encryptedChar : encryptedChar.toLowerCase();
                    keyIndex++;
                } else {
                    encryptedMessage += originalChar;
                }
            }
            return encryptedMessage;
        }

        function encryptElfico(message) {
            const elficoMap = {
                'A': '√Ñ', 'B': '√ü', 'C': '√á', 'D': '√ê', 'E': '√ã', 'F': '∆ë', 'G': 'ƒû', 'H': 'ƒ¶', 'I': '√è',
                'J': 'ƒ¥', 'K': 'ƒ∂', 'L': '≈Å', 'M': 'Œú', 'N': '√ë', 'O': '√ò', 'P': '√û', 'Q': 'Œ©', 'R': '≈ò',
                'S': '≈†', 'T': '≈¶', 'U': '√ú', 'V': '·πº', 'W': '≈¥', 'X': 'Œß', 'Y': '≈∏', 'Z': '≈Ω',
                ' ': ' ¬∑ ', '.': ' ‚óä ', ',': ' ‚ô¶ ', '!': ' ‚òÖ ', '?': ' ‚òÜ '
            };
            let encryptedMessage = '';
            for (let i = 0; i < message.length; i++) {
                const char = message[i].toUpperCase();
                const originalChar = message[i];
                if (elficoMap[char]) {
                    const elficoChar = elficoMap[char];
                    encryptedMessage += (originalChar === char) ? elficoChar : elficoChar.toLowerCase();
                } else {
                    encryptedMessage += originalChar;
                }
            }
            return encryptedMessage;
        }

        function encryptBinary(message) {
            let binaryMessage = '';
            for (let i = 0; i < message.length; i++) {
                const charCode = message.charCodeAt(i);
                const binary = charCode.toString(2).padStart(8, '0');
                binaryMessage += binary + ' ';
            }
            return binaryMessage.trim();
        }

        // Atualizar criptografia
        function updateEncryption() {
            const message = messageInput.value;
            const method = encryptionMethodSelect.value;
            let encryptedText = '';

            keywordInput.style.display = 'none';
            keywordLabel.style.display = 'none';
            emojiInput.style.display = 'none';
            emojiLabel.style.display = 'none';
            vigenereInput.style.display = 'none';
            vigenereLabel.style.display = 'none';

            switch (method) {
                case 'keyword':
                    keywordInput.style.display = 'block';
                    keywordLabel.style.display = 'block';
                    encryptedText = encryptKeywordCipher(message, keywordInput.value);
                    break;
                case 'atbash':
                    encryptedText = encryptAtbash(message);
                    break;
                case 'caesarEmoji':
                    emojiInput.style.display = 'block';
                    emojiLabel.style.display = 'block';
                    encryptedText = encryptCaesarCipher(message, emojiInput.value);
                    break;
                case 'vigenere':
                    vigenereInput.style.display = 'block';
                    vigenereLabel.style.display = 'block';
                    encryptedText = encryptVigenere(message, vigenereInput.value);
                    break;
                case 'elfico':
                    encryptedText = encryptElfico(message);
                    break;
                case 'binario':
                    encryptedText = encryptBinary(message);
                    break;
                default:
                    encryptedText = 'Selecione um m√©todo de criptografia.';
            }
            encryptedOutput.textContent = encryptedText;
        }

        // OCR com Tesseract.js
        imageInput.addEventListener('change', async () => {
            const file = imageInput.files[0];
            if (!file) return;

            encryptedOutput.textContent = "üîé Lendo imagem, aguarde...";

            try {
                const { data: { text } } = await Tesseract.recognize(file, 'por+eng'); 
                messageInput.value = text.trim();
                updateEncryption();
            } catch (err) {
                encryptedOutput.textContent = "‚ùå Erro ao processar a imagem.";
                console.error(err);
            }
        });

        messageInput.addEventListener('input', updateEncryption);
        encryptionMethodSelect.addEventListener('change', updateEncryption);
        keywordInput.addEventListener('input', updateEncryption);
        emojiInput.addEventListener('input', updateEncryption);
        vigenereInput.addEventListener('input', updateEncryption);

        updateEncryption();
    </script>
</body>
</html>
