<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tradutor de Criptografia DEIC-DIG</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: 'Courier New', Courier, monospace;
      background:#0d0d0d; color:#00ff99;
      display:flex; justify-content:center; align-items:center;
      min-height:100vh; padding:20px;
    }
    .frame{
      width:760px; max-width:calc(100% - 40px);
      border-radius:10px; overflow:hidden;
      box-shadow:0 10px 40px rgba(0,255,153,0.08);
      border:1px solid rgba(0,255,153,0.06);
      background:linear-gradient(180deg, rgba(10,10,10,0.98), rgba(15,15,15,0.95));
    }
    .topbar{
      background:linear-gradient(90deg, rgba(0,255,153,0.06), rgba(0,255,153,0.02));
      padding:10px 14px; display:flex; align-items:center; gap:12px;
      border-bottom:1px solid rgba(0,255,153,0.03);
    }
    .dot{ width:12px; height:12px; border-radius:50%;}
    .dot.red{ background:#ff4d4d; box-shadow:0 0 6px rgba(255,77,77,0.2); }
    .dot.yellow{ background:#ffd24d; box-shadow:0 0 6px rgba(255,210,77,0.12); }
    .dot.green{ background:#4dff99; box-shadow:0 0 6px rgba(77,255,153,0.08); }
    h1{ font-size:1.05rem; color:#00ff99; letter-spacing:1px; margin-left:6px; }
    .console-body{ padding:18px; display:grid; grid-template-columns:1fr 360px; gap:18px; }
    label{ color:#bfffdc; font-size:.88rem; }
    textarea, select, input{
      width:100%; padding:10px 12px; margin-top:8px; border-radius:6px;
      border:1px solid rgba(0,255,153,0.08); background:#0f0f0f; color:#00ff99;
      font-size:14px; transition:all .18s; resize:vertical;
    }
    textarea{ min-height:110px; }
    textarea:focus, input:focus, select:focus{ outline:none; box-shadow:0 0 12px rgba(0,255,153,0.06); border-color:rgba(0,255,153,0.22); }
    .controls{ display:flex; gap:8px; margin-top:10px; }
    .btn{ background:transparent; border:1px solid rgba(0,255,153,0.12); padding:8px 10px; cursor:pointer; color:#00ff99; border-radius:6px; }
    .btn:hover{ background:rgba(0,255,153,0.06); }
    #pasteArea{ border:2px dashed rgba(0,255,153,0.06); padding:12px; margin-top:8px; text-align:center; color:#8fffd1; border-radius:6px; cursor:pointer; background:#0f0f0f;}
    #pasteArea:hover{ border-color:rgba(0,255,153,0.14); }
    #preview img{ max-width:100%; max-height:160px; margin-top:10px; border:1px solid rgba(0,255,153,0.04); border-radius:4px; }
    .right-col{ display:flex; flex-direction:column; gap:12px; }
    .output-wrapper{ display:flex; gap:8px; align-items:flex-start; }
    #output{ height:220px; font-family:'Courier New', monospace; }
    .small{ font-size:12px; color:rgba(0,255,153,0.7); }
    .status{ margin-top:6px; font-size:13px; color:#bfffdc; }
    @media (max-width:900px){ .console-body{ grid-template-columns:1fr; } #output{ height:140px; } }
  </style>
</head>
<body>
  <div class="frame">
    <div class="topbar">
      <div class="dot red"></div>
      <div class="dot yellow"></div>
      <div class="dot green"></div>
      <h1>DEIC-DIG ‚Äî CRYPTO TERMINAL</h1>
      <div style="flex:1"></div>
      <div class="small">Tema: Terminal / Escuro</div>
    </div>

    <div class="console-body">
      <div>
        <label for="action">O que deseja fazer?</label>
        <select id="action"><option value="encrypt">Criptografar</option><option value="decrypt">Descriptografar</option></select>

        <label for="method">M√©todo:</label>
        <select id="method"><option value="keyword">Cifra de Palavra-Chave (Vigen√®re)</option></select>

        <label for="message">Digite sua mensagem:</label>
        <textarea id="message" placeholder="Sua mensagem secreta aqui..."></textarea>

        <div class="controls">
          <input type="file" id="imageInput" accept="image/*" class="btn">
          <div id="pasteArea" class="btn" tabindex="0">Colar print (CTRL+V)</div>
          <button id="togglePreviewBtn" class="btn">Ocultar Preview</button>
        </div>

        <div id="preview"></div>

        <label for="keyword">Palavra-Chave:</label>
        <input type="text" id="keyword" placeholder="Ex: DEIC">

        <div class="status" id="ocrStatus"></div>
      </div>

      <div class="right-col">
        <div>
          <label>Resultado:</label>
          <div class="output-wrapper">
            <textarea id="output" readonly></textarea>
            <button id="copyBtn" class="btn">üìã Copiar</button>
          </div>
          <div class="small">Use o bot√£o copiar para enviar r√°pido no chat do RP.</div>
        </div>

        <div>
          <label>Op√ß√µes:</label>
          <div style="display:flex;gap:8px;margin-top:8px;">
            <button id="generateQR" class="btn">Gerar QR (opcional)</button>
            <button id="clearBtn" class="btn">Limpar</button>
          </div>
          <div style="margin-top:8px;color:#9fffd1;font-size:12px">Dica: prints recortados da pr√≥pria mensagem aumentam acur√°cia do OCR.</div>
        </div>

        <div>
          <label>Confian√ßa OCR:</label>
          <div id="ocrConfidence" class="small">‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Depend√™ncias -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <script>
    // elementos
    const messageInput = document.getElementById('message' );
    const keywordInput = document.getElementById('keyword');
    const output = document.getElementById('output');
    const methodSelect = document.getElementById('method');
    const actionSelect = document.getElementById('action');
    const imageInput = document.getElementById('imageInput');
    const pasteArea = document.getElementById('pasteArea');
    const preview = document.getElementById('preview');
    const ocrStatus = document.getElementById('ocrStatus');
    const ocrConfidence = document.getElementById('ocrConfidence');
    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const togglePreviewBtn = document.getElementById('togglePreviewBtn');
    const generateQR = document.getElementById('generateQR');

    let worker = null;
    let previewVisible = true;

    // ---------------- Cifras (l√≥gica original mantida) ----------------
    function encryptKeywordCipher(text, keyword) {
        if (!keyword || keyword.trim() === "") return text;
        const cleanKeyword = keyword.toUpperCase().replace(/[^A-Z]/g, "");
        if (cleanKeyword.length === 0) return text;
        let result = "";
        let keywordIndex = 0;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const upperChar = char.toUpperCase();
            if (upperChar >= 'A' && upperChar <= 'Z') {
                const tChar = upperChar.charCodeAt(0) - 65;
                const kChar = cleanKeyword.charCodeAt(keywordIndex % cleanKeyword.length) - 65;
                const enc = (tChar + kChar) % 26;
                let newChar = String.fromCharCode(enc + 65);
                if (char === char.toLowerCase()) {
                    newChar = newChar.toLowerCase();
                }
                result += newChar;
                keywordIndex++;
            } else {
                result += char;
            }
        }
        return result;
    }

    function decryptKeywordCipher(text, keyword) {
        if (!keyword || keyword.trim() === "") return text;
        const cleanKeyword = keyword.toUpperCase().replace(/[^A-Z]/g, "");
        if (cleanKeyword.length === 0) return text;
        let result = "";
        let keywordIndex = 0;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const upperChar = char.toUpperCase();
            if (upperChar >= 'A' && upperChar <= 'Z') {
                const tChar = upperChar.charCodeAt(0) - 65;
                const kChar = cleanKeyword.charCodeAt(keywordIndex % cleanKeyword.length) - 65;
                const dec = (tChar - kChar + 26) % 26;
                let newChar = String.fromCharCode(dec + 65);
                if (char === char.toLowerCase()) {
                    newChar = newChar.toLowerCase();
                }
                result += newChar;
                keywordIndex++;
            } else {
                result += char;
            }
        }
        return result;
    }
    // ---------------- fim cifras ----------------

    function updateOutput(){
      const method = methodSelect.value;
      const action = actionSelect.value;
      const text = messageInput.value;
      const keyword = keywordInput.value;
      if (!keyword || keyword.trim() === "") {
        output.value = text;
        return;
      }
      if (method === 'keyword') {
        output.value = action === 'encrypt' ? encryptKeywordCipher(text, keyword) : decryptKeywordCipher(text, keyword);
      }
    }

    // eventos
    messageInput.addEventListener('input', updateOutput);
    keywordInput.addEventListener('input', updateOutput);
    methodSelect.addEventListener('change', updateOutput);
    actionSelect.addEventListener('change', updateOutput);

    copyBtn.addEventListener('click', async () => {
      if (output.value.trim() === '') return;
      try {
        await navigator.clipboard.writeText(output.value);
        flashStatus('Copiado para clipboard');
      } catch (e) {
        flashStatus('Falha ao copiar');
      }
    });

    clearBtn.addEventListener('click', () => {
      messageInput.value = '';
      keywordInput.value = '';
      output.value = '';
      preview.innerHTML = '';
      ocrStatus.textContent = '';
      ocrConfidence.textContent = '‚Äî';
      imageInput.value = ''; // Limpa o input de arquivo
      updateOutput();
    });

    togglePreviewBtn.addEventListener('click', () => {
      previewVisible = !previewVisible;
      preview.style.display = previewVisible ? 'block' : 'none';
      togglePreviewBtn.textContent = previewVisible ? 'Ocultar Preview' : 'Mostrar Preview';
    });

    function flashStatus(text) {
      ocrStatus.textContent = text;
      setTimeout(() => { if (ocrStatus.textContent === text) ocrStatus.textContent = ''; }, 2500);
    }

    imageInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (f) processOCR(f);
    });

    pasteArea.addEventListener('paste', handlePaste);
    messageInput.addEventListener('paste', handlePaste);

    function handlePaste(event) {
      const items = (event.clipboardData || window.clipboardData).items;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf('image') !== -1) {
          const file = items[i].getAsFile();
          if(file){
            event.preventDefault();
            processOCR(file);
            return;
          }
        }
      }
    }

    window.addEventListener('dragover', e => e.preventDefault());
    window.addEventListener('drop', e => {
      e.preventDefault();
      if (e.dataTransfer.files && e.dataTransfer.files.length) {
        processOCR(e.dataTransfer.files[0]);
      }
    });

    // ----------------- Preprocess (melhorado) -----------------
    async function preprocessImageFile(file, opts = {}) {
      const scale = opts.scale || 2.0;
      const tile = opts.tile || 32;
      const thrOffset = (typeof opts.thrOffset === 'number') ? opts.thrOffset : 10;
      const unsharp = opts.unsharp || false;

      return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = Math.round(img.width * scale);
            canvas.height = Math.round(img.height * scale);
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imgData.data;

            // Grayscale + contrast stretch
            let minL = 255, maxL = 0;
            for (let i = 0; i < data.length; i += 4) {
              const lum = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
              if (lum < minL) minL = lum;
              if (lum > maxL) maxL = lum;
            }
            const range = Math.max(1, maxL - minL);
            for (let i = 0; i < data.length; i += 4) {
              let lum = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
              lum = ((lum - minL) * 255) / range;
              data[i] = data[i+1] = data[i+2] = lum;
            }
            ctx.putImageData(imgData, 0, 0);

            if (unsharp) {
              const blurredData = new Uint8ClampedArray(data.length);
              const w = canvas.width, h = canvas.height;
              for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                  let sum = 0;
                  for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                      sum += data[((y + dy) * w + (x + dx)) * 4];
                    }
                  }
                  const idx = (y * w + x) * 4;
                  blurredData[idx] = blurredData[idx+1] = blurredData[idx+2] = sum / 9;
                  blurredData[idx+3] = 255;
                }
              }
              const amount = 0.8;
              for (let i = 0; i < data.length; i += 4) {
                const orig = data[i];
                const blur = blurredData[i];
                const sharpened = orig + amount * (orig - blur);
                data[i] = data[i+1] = data[i+2] = Math.max(0, Math.min(255, sharpened));
              }
              ctx.putImageData(imgData, 0, 0);
            }

            // Adaptive threshold
            const binData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < canvas.height; y += tile) {
              for (let x = 0; x < canvas.width; x += tile) {
                let sum = 0, count = 0;
                for (let yy = y; yy < Math.min(y + tile, canvas.height); yy++) {
                  for (let xx = x; xx < Math.min(x + tile, canvas.width); xx++) {
                    sum += data[(yy * canvas.width + xx) * 4];
                    count++;
                  }
                }
                const mean = sum / count;
                for (let yy = y; yy < Math.min(y + tile, canvas.height); yy++) {
                  for (let xx = x; xx < Math.min(x + tile, canvas.width); xx++) {
                    const idx = (yy * canvas.width + xx) * 4;
                    const val = data[idx] < (mean - thrOffset) ? 0 : 255;
                    binData.data[idx] = binData.data[idx+1] = binData.data[idx+2] = val;
                  }
                }
              }
            }
            ctx.putImageData(binData, 0, 0);

            URL.revokeObjectURL(url);
            resolve(canvas);
          } catch (err) {
            URL.revokeObjectURL(url);
            reject(err);
          }
        };
        img.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    // ----------------- Tesseract worker (Otimizado) -----------------
    async function ensureWorker() {
      if (worker) return worker;
      ocrStatus.textContent = 'Carregando m√≥dulo OCR (s√≥ na 1¬™ vez)...';
      worker = await Tesseract.createWorker({
        logger: m => {
          if (m.status === 'recognizing text') {
            const p = Math.round(m.progress * 100);
            ocrStatus.textContent = `Processando OCR: ${p}%`;
          }
        }
      });

      try {
        await worker.loadLanguage('por+eng');
        await worker.initialize('por+eng');
        await worker.setParameters({
          tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
        });
        ocrStatus.textContent = 'M√≥dulo OCR pronto.';
        return worker;
      } catch (err) {
        console.error('Erro ao inicializar worker Tesseract:', err);
        ocrStatus.textContent = 'Falha ao carregar OCR.';
        worker = null; // Reseta para tentar de novo
        throw err;
      }
    }

    async function processOCR(file) {
      if (!file) return;
      preview.innerHTML = '';
      ocrStatus.textContent = 'Preparando...';
      ocrConfidence.textContent = '‚Äî';

      const attempts = [
        { scale: 2.0, tile: 32, thrOffset: 10, unsharp: false, psm: Tesseract.PSM.SINGLE_BLOCK },
        { scale: 3.0, tile: 24, thrOffset: 8, unsharp: true, psm: Tesseract.PSM.SINGLE_LINE },
        { scale: 2.5, tile: 16, thrOffset: 12, unsharp: true, psm: Tesseract.PSM.SINGLE_WORD },
        { scale: 3.0, tile: 12, thrOffset: 6, unsharp: true, psm: Tesseract.PSM.SINGLE_CHAR }
      ];

      let lastError = null;
      try {
        const wk = await ensureWorker();

        for (let i = 0; i < attempts.length; i++) {
          const a = attempts[i];
          ocrStatus.textContent = `Pre-processando (tente ${i+1}/${attempts.length})...`;
          let canvas;
          try {
            canvas = await preprocessImageFile(file, a);
          } catch (err) {
            lastError = err;
            continue;
          }

          preview.innerHTML = '';
          const imgEl = document.createElement('img');
          imgEl.src = canvas.toDataURL('image/png');
          preview.appendChild(imgEl);

          await wk.setParameters({ tessedit_pageseg_mode: a.psm });

          ocrStatus.textContent = `Reconhecendo (tente ${i+1}/${attempts.length})...`;
          try {
            const { data: { text, confidence } } = await wk.recognize(canvas);
            const conf = Math.round(confidence);
            console.log(`Tentativa ${i+1} -> texto: "${text.trim()}" (conf ${conf})`);
            if (text && text.trim().length > 0 && conf >= 40) {
              messageInput.value = text.trim();
              messageInput.focus();
              ocrStatus.textContent = 'Texto extra√≠do com sucesso!';
              ocrConfidence.textContent = `${conf}%`;
              updateOutput();
              return;
            } else {
              lastError = new Error(`Baixa confian√ßa (${conf}) ou texto vazio.`);
            }
          } catch (err) {
            lastError = err;
          }
        }

        flashStatus('N√£o foi poss√≠vel extrair texto.');
        console.error('√öltimo erro OCR:', lastError);
      } catch (err) {
        flashStatus('Erro cr√≠tico no OCR.');
        console.error('Erro ao processar OCR:', err);
      }
    }

    // QR generator
    generateQR.addEventListener('click', () => {
      const text = output.value.trim();
      if (!text) { flashStatus('Nenhum resultado para gerar QR'); return; }
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, text, { margin: 2, scale: 6 }, (error) => {
          if (error) {
              flashStatus('Erro ao gerar QR');
              return;
          }
          const w = window.open('');
          w.document.write('<html><body style="margin:0; background:#0d0d0d; display:flex; justify-content:center; align-items:center;"></body></html>');
          w.document.body.appendChild(canvas);
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
        updateOutput();
        // Pr√©-aquece o worker para deixar a primeira extra√ß√£o mais r√°pida
        ensureWorker();
    });
  </script>
</body>
</html>
